# 第一步：模式判断与交互框架实现（修正版）

## 目标

根据后端返回的 `mode` 字段，判断是模拟模式还是交互模式：
- **模拟模式**：物体有初速度，用户不可拖拽
- **交互模式**：物体无初速度，用户可拖拽探索

两种模式物理引擎都立即运行。

---

## 代码量估算

- `PhysicsInputBox.jsx` 修改：约 80 行
- `physicsEngine.js` 修改：约 70 行
- **总计：约 150 行**

---

## 核心改动点

### 改动 1：根据 mode 决定是否添加鼠标交互

**后端返回数据**：
```javascript
{
  "mode": "simulation",        // 或 "interactive"
  "enableInteraction": false,  // 或 true
  "objects": [...]
}
```

**前端逻辑**：
```javascript
// 🔑 根据 mode 决定是否添加鼠标约束
if (mode === 'interactive' && enableInteraction) {
  // 添加鼠标拖拽约束
  const mouseConstraint = MouseConstraint.create(engine, {...});
  Composite.add(engine.world, mouseConstraint);
}

// 两种模式都立即启动
Runner.run(runner, engine);
```

---

### 改动 2：添加鼠标拖拽约束

**核心代码**（在 `physicsEngine.js` 中）：
```javascript
import { MouseConstraint, Mouse } from 'matter-js';

export function runSimulation({ container, objects, ... }) {
  // ... 创建引擎、渲染器 ...
  
  // 🆕 创建鼠标对象
  const mouse = Mouse.create(render.canvas);
  
  // 🆕 创建鼠标约束（用于拖拽）
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
      stiffness: 0.2,    // 拖拽刚度
      damping: 0.1,      // 拖拽阻尼
      render: { 
        visible: false   // 不显示约束线
      }
    }
  });
  
  // 🆕 添加到物理世界
  Composite.add(engine.world, mouseConstraint);
  
  // 🆕 立即启动引擎
  Runner.run(runner, engine);
  
  return {
    engine,
    runner,
    render,
    mouseConstraint  // 🆕 返回引用（用于后续控制）
  };
}
```

**效果**：
- ✅ 用户可以拖拽**动态物体**（滑块、摆球、重物等）
- ❌ 用户**无法拖拽静态物体**（地面、墙壁、轴心点等）
- ✅ 拖拽过程中，其他物体继续运动
- ✅ 松手后，被拖拽物体立即按物理规律运动

---

### 改动 3：保存初始状态（用于重置功能）

**代码实现**：
```javascript
export function runSimulation({ ... }) {
  // ... 创建所有物体后 ...
  
  // 🆕 保存所有物体的初始状态
  const initialStates = bodies.map(body => ({
    id: body.id,
    position: { x: body.position.x, y: body.position.y },
    velocity: { x: body.velocity.x, y: body.velocity.y },
    angle: body.angle,
    angularVelocity: body.angularVelocity
  }));
  
  return {
    // ... 其他返回值 ...
    
    // 🆕 重置方法
    reset: () => {
      initialStates.forEach(state => {
        const body = bodies.find(b => b.id === state.id);
        if (body) {
          Body.setPosition(body, state.position);
          Body.setVelocity(body, state.velocity);
          Body.setAngle(body, state.angle);
          Body.setAngularVelocity(body, state.angularVelocity);
        }
      });
      // 注意：引擎不停止，继续运行
    }
  };
}
```

**重置效果**：
- 所有物体回到初始位置
- 速度归零
- 物理引擎**继续运行**（不暂停）

---

### 改动 4：保存模式信息（用于UI显示）

**在 PhysicsInputBox.jsx 中添加状态**：
```javascript
const [simulationMode, setSimulationMode] = useState(null);

// 创建模拟时保存模式
const handleStartSimulate = async () => {
  const response = await axios.post('/api/simulate', {...});
  const { mode, objects, constraints } = response.data;
  
  // 🔑 保存模式信息
  setSimulationMode(mode);  // "simulation" 或 "interactive"
  
  const sim = runSimulation({
    mode,
    enableInteraction: mode === 'interactive',
    objects,
    constraints,
    ...
  });
};
```

---

## 完整代码示例

### PhysicsInputBox.jsx 修改

**位置**：找到 `handleStartSimulate` 函数

```javascript
const handleStartSimulate = async () => {
  setLoading(true);
  setError('');
  
  try {
    // 调用后端获取物理参数
    const response = await axios.post('/api/simulate', {
      assignments: assignments,
      constraints: constraintRelations,
      imageRect: imgRect,
      naturalSize: naturalSize
    });
    
    const { objects, constraints } = response.data;
    
    // 🔑 创建物理模拟（立即启动）
    const sim = runSimulation({
      container: simRef.current,
      objects,
      constraints,
      imageRect: imgRect,
      naturalSize,
      paused: false  // 🔑 立即运行
    });
    
    runningSimulation.current = sim;
    setCanDownload(true);
    
  } catch (err) {
    setError('创建模拟失败：' + err.message);
  } finally {
    setLoading(false);
  }
};

// 🆕 重置功能
const handleResetSimulation = () => {
  if (runningSimulation.current && runningSimulation.current.reset) {
    runningSimulation.current.reset();
    setIsPlayMode(false);  // 重置后回到交互模式
  }
};

// 🆕 播放/交互模式切换
const handleTogglePlayMode = () => {
  if (!runningSimulation.current) return;
  
  if (isPlayMode) {
    runningSimulation.current.enableInteraction();
    setIsPlayMode(false);
  } else {
    runningSimulation.current.disableInteraction();
    setIsPlayMode(true);
  }
};
```

**UI 部分**：
```jsx
{/* 模拟画布容器 */}
<div style={{ position: 'relative' }}>
  {/* 画布 */}
  <div ref={simRef} style={{ width: '100%', height: '600px' }}>
    {/* Matter.js 会在这里创建 canvas */}
  </div>
  
  {/* 🔑 只在交互模式下显示重置按钮（右下角） */}
  {canDownload && simulationMode === 'interactive' && (
    <button 
      onClick={handleResetSimulation}
      style={{
        position: 'absolute',
        bottom: '20px',
        right: '20px',
        padding: '12px 24px',
        backgroundColor: '#ff6600',
        color: '#fff',
        border: 'none',
        borderRadius: '8px',
        cursor: 'pointer',
        fontSize: '16px',
        fontWeight: 'bold',
        boxShadow: '0 4px 12px rgba(255, 102, 0, 0.3)',
        transition: 'all 0.3s ease',
        zIndex: 1000
      }}
      onMouseEnter={(e) => {
        e.currentTarget.style.backgroundColor = '#ff8833';
        e.currentTarget.style.transform = 'translateY(-2px)';
      }}
      onMouseLeave={(e) => {
        e.currentTarget.style.backgroundColor = '#ff6600';
        e.currentTarget.style.transform = 'translateY(0)';
      }}
    >
      🔄 重置场景
    </button>
  )}
</div>

{/* 底部控制按钮 */}
{canDownload && (
  <div style={{ display: 'flex', gap: '10px', marginTop: '20px' }}>
    <button onClick={handleDownloadAnimation}>
      💾 下载动画
    </button>
  </div>
)}
```

---

### physicsEngine.js 完整修改

```javascript
import Matter from 'matter-js';
const { Engine, Render, Runner, Bodies, Body, Composite, Mouse, MouseConstraint, Events } = Matter;

export function runSimulation({ 
  container, 
  mode = 'simulation',           // 🔑 新增：模式
  enableInteraction = false,     // 🔑 新增：是否启用交互
  objects = [], 
  constraints = [], 
  imageRect, 
  naturalSize = { w: 0, h: 0 }
}) {
  
  // 创建引擎
  const engine = Engine.create({
    gravity: { x: 0, y: 1 }
  });
  
  // 创建渲染器
  const render = Render.create({
    element: container,
    engine: engine,
    options: {
      width: container.clientWidth,
      height: container.clientHeight,
      wireframes: false,
      background: '#f0f0f0'
    }
  });
  
  // 创建 Runner
  const runner = Runner.create();
  
  // 计算缩放比例
  const sx = container.clientWidth / naturalSize.w;
  const sy = container.clientHeight / naturalSize.h;
  
  // 创建物体
  const bodies = [];
  const bodiesMap = {};
  
  objects.forEach(obj => {
    // 转换轮廓坐标
    const scaledVertices = obj.contour.map(pt => ({
      x: pt.x * sx,
      y: pt.y * sy
    }));
    
    // 创建刚体
    const body = Bodies.fromVertices(
      scaledVertices[0].x,
      scaledVertices[0].y,
      [scaledVertices],
      {
        isStatic: obj.role === 'static',
        restitution: obj.parameters?.restitution || 0.3,
        friction: obj.parameters?.friction || 0.5,
        render: {
          sprite: obj.sprite ? {
            texture: obj.sprite.url,
            xScale: sx,
            yScale: sy
          } : undefined
        }
      }
    );
    
    bodies.push(body);
    bodiesMap[obj.name] = body;
  });
  
  // 添加物体到世界
  Composite.add(engine.world, bodies);
  
  // 🆕 保存初始状态
  const initialStates = bodies.map(body => ({
    id: body.id,
    position: { x: body.position.x, y: body.position.y },
    velocity: { x: body.velocity.x, y: body.velocity.y },
    angle: body.angle,
    angularVelocity: body.angularVelocity
  }));
  
  // 🔑 只在交互模式下创建鼠标约束
  let mouseConstraint = null;
  if (mode === 'interactive' && enableInteraction) {
    const mouse = Mouse.create(render.canvas);
    mouseConstraint = MouseConstraint.create(engine, {
      mouse: mouse,
      constraint: {
        stiffness: 0.2,
        damping: 0.1,
        render: { visible: false }
      }
    });
    Composite.add(engine.world, mouseConstraint);
  }
  
  // 启动渲染
  Render.run(render);
  
  // 🔑 两种模式都立即启动引擎
  Runner.run(runner, engine);
  
  return {
    engine,
    runner,
    render,
    bodies,
    mode,  // 🔑 返回模式信息
    
    // 🆕 重置方法（只在交互模式下使用）
    reset: () => {
      initialStates.forEach(state => {
        const body = bodies.find(b => b.id === state.id);
        if (body) {
          Body.setPosition(body, state.position);
          Body.setVelocity(body, state.velocity);
          Body.setAngle(body, state.angle);
          Body.setAngularVelocity(body, state.angularVelocity);
        }
      });
    },
    
    // 停止模拟
    stop: () => {
      Runner.stop(runner);
      Render.stop(render);
    }
  };
}
```

---

## 完成后的前端效果（详细描述）

### 场景A：模拟模式

**后端返回**：`mode: "simulation"`

**点击"创建模拟"后**：

1. **画布立即运行**：
   - 滑块A 立即以初速度运动（有初速度参数）
   - 物体按照预设参数模拟
   - 用户**无法拖拽**任何物体

2. **UI显示**：
   - 右下角：**无重置按钮**（模拟模式不需要）
   - 底部：只有"💾 下载动画"按钮

3. **鼠标光标**：
   - 悬停在任何物体上 → 光标保持**箭头**
   - 无法拖拽

---

### 场景B：交互模式

**后端返回**：`mode: "interactive"`

**点击"创建模拟"后**：

1. **画布立即运行**：
   - 物体**静止**（无初速度）
   - 受重力影响（如悬空物体会掉落）
   - 用户**可以拖拽**动态物体

2. **UI显示**：
   - 右下角：**橙色"🔄 重置场景"按钮**
   - 底部：只有"💾 下载动画"按钮

3. **鼠标光标变化**：
   - 悬停在**动态物体**上 → 光标变为**手型**（可拖拽）
   - 悬停在**静态物体**上 → 光标保持**箭头**（不可拖拽）
   - 悬停在**空白处** → 光标保持**箭头**

---

### 阶段二：交互模式的拖拽体验

**测试场景**：滑轮组（交互模式）

4. **拖拽重物**：
   - 点击并按住重物
   - 拖动向下
   - **观察**：
     - 重物跟随鼠标移动
     - 绳子被拉紧
     - 动滑轮被向上托起
     - 定滑轮旋转

5. **松手后**：
   - 重物**立即掉落**
   - 动滑轮上升
   - 滑轮旋转
   - **无需点击任何按钮，立即看到效果**

6. **反复拖拽**：
   - 可以随时拖动任何动态物体（重物、摆球等）
   - 可以在物体运动过程中抓住它
   - 可以改变物体的运动方向
   - **完全自由的物理沙盒体验**

---

### 阶段三：点击"🔄 重置场景"按钮（只在交互模式）

7. **重置效果**：
   - 所有物体**瞬间回到初始位置**
   - 所有速度**归零**
   - 物理引擎**继续运行**（不暂停）
   - 重置后立即可以拖拽

8. **重置后可以**：
   - 立即拖拽物体到新位置
   - 尝试不同的初始条件
   - 反复探索物理效果

---

## 两种模式对比表

| 特性 | 模拟模式 | 交互模式 |
|------|---------|---------|
| **后端标识** | `mode: "simulation"` | `mode: "interactive"` |
| **适用场景** | 有明确初始参数的题目 | 无初始参数或适合探索 |
| **物体初始参数** | 有初速度、角度等 | 只有质量等基本参数 |
| **物体初始状态** | 立即运动 | 静止（受重力） |
| **物理引擎状态** | ✅ 运行 | ✅ 运行 |
| **可否拖拽物体** | ❌ 不可以 | ✅ 可以 |
| **鼠标光标（物体上）** | 箭头 | 手型 |
| **右下角按钮** | 无 | 🔄 重置场景 |
| **用户体验** | 观看模拟 | 物理沙盒 |

---

## 测试清单

### 测试 1：基础拖拽

**场景**：滑块碰撞

1. 上传滑块碰撞图片，选择元素
2. 点击"创建模拟"
3. ✅ 确认：物体立即开始运动
4. 拖动滑块 A 到高处
5. ✅ 确认：滑块 A 跟随鼠标
6. 松手
7. ✅ 确认：滑块 A 立即掉落，碰撞滑块 B

---

### 测试 2：模式判断正确性

**测试模拟模式**：
1. 上传有明确速度参数的题目图片（如滑块碰撞）
2. 后端应返回 `mode: "simulation"`
3. ✅ 确认：创建后物体立即运动
4. ✅ 确认：无法拖拽物体
5. ✅ 确认：右下角无重置按钮

**测试交互模式**：
1. 上传滑轮组或单摆图片
2. 后端应返回 `mode: "interactive"`
3. ✅ 确认：创建后物体静止或自然下落
4. ✅ 确认：可以拖拽物体
5. ✅ 确认：右下角有"🔄 重置场景"按钮

---

### 测试 3：重置功能（交互模式）

1. 在交互模式下，拖拽物体到随意位置
2. 松手观察运动
3. 点击"🔄 重置场景"
4. ✅ 确认：物体回到初始位置
5. ✅ 确认：速度归零
6. ✅ 确认：立即可以拖拽物体

---

### 测试 4：静态物体不可拖拽

1. 创建包含地面、墙壁的场景
2. 尝试拖拽地面
3. ✅ 确认：拖不动（鼠标不显示手型）
4. 拖拽动态物体
5. ✅ 确认：可以拖拽

---

### 测试 5：运动中抓取物体

1. 创建单摆场景
2. 等待摆球摆动
3. 在摆球运动过程中，快速点击并拖拽摆球
4. ✅ 确认：可以抓住运动中的物体
5. 拖到新位置松手
6. ✅ 确认：摆球从新位置继续摆动

---

## 常见问题

### Q1：拖拽时物体抖动或不稳定？

**原因**：鼠标约束的 `stiffness` 过高或过低

**解决**：
```javascript
stiffness: 0.2  // 推荐值 0.1 - 0.3
damping: 0.1    // 推荐值 0.05 - 0.15
```

---

### Q2：重置后物体位置不准确？

**原因**：初始状态保存时机不对

**解决**：确保在所有物体创建完成后再保存初始状态
```javascript
// ✅ 正确
Composite.add(engine.world, bodies);
const initialStates = bodies.map(...);  // 添加后再保存

// ❌ 错误
const initialStates = bodies.map(...);  // 添加前就保存
Composite.add(engine.world, bodies);
```

---

### Q3：播放模式切换无效？

**原因**：鼠标约束引用丢失

**解决**：使用 `let` 保存引用，确保可以重新添加
```javascript
let mouseConstraintRef = mouseConstraint;

// 移除时
Composite.remove(engine.world, mouseConstraintRef);

// 重新添加时
Composite.add(engine.world, mouseConstraintRef);
```

---

## 下一步

完成第一步后，进入：
**交互模式实现-第二步-绳子系统.md**

---

**文档版本**：v1.0  
**预计开发时间**：1-2 天

