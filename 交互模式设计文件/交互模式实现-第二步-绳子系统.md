# 第二步：Verlet 绳子系统实现

## 目标

实现柔性绳子，用户可以通过鼠标交互创建绳子连接，绳子会自然下垂、摆动，可以连接刚体或固定在空中。

---

## 代码量估算

- `VerletRope.js` 新建：约 180 行
- `PhysicsInputBox.jsx` 修改：约 50 行
- `physicsEngine.js` 修改：约 20 行
- **总计：约 250 行**

---

## 核心算法：Verlet 积分

**来源**：`绳子实现算法.html` 第 480-731 行

### 算法原理

Verlet 积分是一种简单但强大的物理模拟方法，特别适合模拟绳子、布料等柔性体。

**核心公式**：
```javascript
// 当前速度 = (当前位置 - 旧位置) * 阻尼
vx = (p.x - p.oldX) * damping;
vy = (p.y - p.oldY) * damping;

// 更新位置
p.oldX = p.x;
p.oldY = p.y;
p.x += vx + gravity.x;
p.y += vy + gravity.y;
```

**优点**：
- ✅ 不需要显式存储速度变量
- ✅ 通过位置历史隐式计算速度
- ✅ 非常稳定，适合大量节点

---

## 文件结构

### 新建文件：VerletRope.js

**文件路径**：`frontend/src/utils/VerletRope.js`

完整代码如下：

```javascript
/**
 * Verlet 绳子系统
 * 基于 Verlet 积分的柔性绳子物理模拟
 * 
 * 核心算法来源：绳子实现算法.html
 */

import Matter from 'matter-js';
const { Body } = Matter;

export class VerletRope {
  /**
   * 创建绳子
   * @param {Object} startPoint - 起点坐标 {x, y}
   * @param {Object} endPoint - 终点坐标 {x, y}
   * @param {Number} segments - 绳子节点数量（默认 50）
   */
  constructor(startPoint, endPoint, segments = 50) {
    this.segments = segments;
    this.points = [];
    
    // 🔑 物理参数（来自 绳子实现算法.html）
    this.stiffness = 0.95;   // 刚度：0.95 表示几乎不可伸长
    this.damping = 0.98;     // 阻尼：0.98 表示摆动会缓慢衰减
    this.gravity = 0.15;     // 重力加速度（每帧）
    
    // 计算绳子总长度
    const dx = endPoint.x - startPoint.x;
    const dy = endPoint.y - startPoint.y;
    const totalLength = Math.sqrt(dx * dx + dy * dy);
    this.segmentLength = totalLength / segments;
    
    // 🔑 初始化绳子节点（直线分布）
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const x = startPoint.x + dx * t;
      const y = startPoint.y + dy * t;
      
      this.points.push({
        x: x,
        y: y,
        oldX: x,      // 用于计算速度
        oldY: y,
        pinned: false // 是否固定（端点通常固定）
      });
    }
    
    // 连接信息（绳子两端可以附着到刚体）
    this.attachments = {
      start: null,  // { body, offset }
      end: null
    };
  }
  
  /**
   * 将绳子端点附着到刚体
   * @param {Object} bodyData - { body: Matter.Body, offset: {x, y} }
   * @param {Boolean} isStart - true: 起点, false: 终点
   */
  attachToBody(bodyData, isStart) {
    if (isStart) {
      this.attachments.start = bodyData;
      this.points[0].pinned = true;
    } else {
      this.attachments.end = bodyData;
      this.points[this.points.length - 1].pinned = true;
    }
  }
  
  /**
   * 更新物理（每帧调用）
   */
  update() {
    // 🔑 步骤 1：更新附着点位置（跟随刚体）
    this.updateAttachments();
    
    // 🔑 步骤 2：Verlet 积分（更新速度和位置）
    this.updateVerletIntegration();
    
    // 🔑 步骤 3：约束求解（保持节点间距）
    this.solveConstraints();
    
    // 🔑 步骤 4：对连接的刚体施加绳子拉力
    this.applyTensionToBody();
  }
  
  /**
   * 步骤 1：更新附着点位置
   */
  updateAttachments() {
    // 起点附着
    if (this.attachments.start) {
      const body = this.attachments.start.body;
      const offset = this.attachments.start.offset || { x: 0, y: 0 };
      
      // 考虑刚体旋转（旋转矩阵变换）
      const cos = Math.cos(body.angle);
      const sin = Math.sin(body.angle);
      
      this.points[0].x = body.position.x + offset.x * cos - offset.y * sin;
      this.points[0].y = body.position.y + offset.x * sin + offset.y * cos;
      this.points[0].oldX = this.points[0].x;
      this.points[0].oldY = this.points[0].y;
    }
    
    // 终点附着
    if (this.attachments.end) {
      const body = this.attachments.end.body;
      const offset = this.attachments.end.offset || { x: 0, y: 0 };
      
      const cos = Math.cos(body.angle);
      const sin = Math.sin(body.angle);
      const lastIdx = this.points.length - 1;
      
      this.points[lastIdx].x = body.position.x + offset.x * cos - offset.y * sin;
      this.points[lastIdx].y = body.position.y + offset.x * sin + offset.y * cos;
      this.points[lastIdx].oldX = this.points[lastIdx].x;
      this.points[lastIdx].oldY = this.points[lastIdx].y;
    }
  }
  
  /**
   * 步骤 2：Verlet 积分
   */
  updateVerletIntegration() {
    for (let i = 0; i < this.points.length; i++) {
      const p = this.points[i];
      if (p.pinned) continue;  // 固定点不更新
      
      // 🔑 Verlet 速度计算
      const vx = (p.x - p.oldX) * this.damping;
      const vy = (p.y - p.oldY) * this.damping;
      
      // 保存当前位置为旧位置
      p.oldX = p.x;
      p.oldY = p.y;
      
      // 🔑 更新位置：位置 += 速度 + 重力
      p.x += vx;
      p.y += vy + this.gravity;
    }
  }
  
  /**
   * 步骤 3：约束求解（多次迭代）
   */
  solveConstraints() {
    // 🔑 多次迭代提高稳定性（5次）
    for (let iter = 0; iter < 5; iter++) {
      this.solveDistanceConstraints();
    }
  }
  
  /**
   * 距离约束：保持相邻节点间距
   */
  solveDistanceConstraints() {
    for (let i = 0; i < this.points.length - 1; i++) {
      const p1 = this.points[i];
      const p2 = this.points[i + 1];
      
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 0.0001) continue;  // 防止除零
      
      // 🔑 计算偏移量（让距离恢复到目标长度）
      const diff = (this.segmentLength - dist) / dist * this.stiffness;
      const offsetX = dx * diff * 0.5;
      const offsetY = dy * diff * 0.5;
      
      // 🔑 双向调整（两个节点各移动一半）
      if (!p1.pinned) {
        p1.x -= offsetX;
        p1.y -= offsetY;
      }
      if (!p2.pinned) {
        p2.x += offsetX;
        p2.y += offsetY;
      }
    }
  }
  
  /**
   * 步骤 4：对刚体施加绳子拉力
   * 🔑 只在绳子被拉紧时施加力（单向约束）
   */
  applyTensionToBody() {
    // 计算绳子当前总长度
    let currentLength = 0;
    for (let i = 0; i < this.points.length - 1; i++) {
      const dx = this.points[i + 1].x - this.points[i].x;
      const dy = this.points[i + 1].y - this.points[i].y;
      currentLength += Math.sqrt(dx * dx + dy * dy);
    }
    
    // 计算绳子的原始长度
    const restLength = this.segmentLength * this.segments;
    
    // 🔑 只有当绳子被拉伸时才施加力
    const stretch = currentLength - restLength;
    if (stretch <= 0) return;  // 绳子松弛，不施力
    
    // 🔑 张力与拉伸量成正比
    const tensionForce = stretch * 0.0003;
    
    // 对起点刚体施加力
    if (this.attachments.start && this.attachments.start.body) {
      const body = this.attachments.start.body;
      const p0 = this.points[0];
      const p1 = this.points[1];
      const dx = p1.x - p0.x;
      const dy = p1.y - p0.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 0) {
        Body.applyForce(body, body.position, {
          x: (dx / dist) * tensionForce,
          y: (dy / dist) * tensionForce
        });
      }
    }
    
    // 对终点刚体施加力
    if (this.attachments.end && this.attachments.end.body) {
      const body = this.attachments.end.body;
      const lastIdx = this.points.length - 1;
      const pLast = this.points[lastIdx];
      const pPrev = this.points[lastIdx - 1];
      const dx = pPrev.x - pLast.x;
      const dy = pPrev.y - pLast.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 0) {
        Body.applyForce(body, body.position, {
          x: (dx / dist) * tensionForce,
          y: (dy / dist) * tensionForce
        });
      }
    }
  }
  
  /**
   * 渲染绳子
   * @param {CanvasRenderingContext2D} ctx - 画布上下文
   */
  render(ctx) {
    ctx.beginPath();
    ctx.moveTo(this.points[0].x, this.points[0].y);
    
    // 🔑 绘制平滑曲线（连接所有节点）
    for (let i = 1; i < this.points.length; i++) {
      ctx.lineTo(this.points[i].x, this.points[i].y);
    }
    
    // 🔑 绳子样式：黑色，粗 4px
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
  }
}
```

---

## 用户交互流程实现

### 在 PhysicsInputBox.jsx 中添加绳子创建逻辑

```javascript
// 🆕 绳子创建状态
const [ropeCreationState, setRopeCreationState] = useState(null);
// 结构：{ firstPoint: {x, y, bodyName}, mousePosition: {x, y} }

/**
 * 处理画布点击（绳子工具）
 */
const handleCanvasClickForRope = (clickPoint, imgRect) => {
  if (currentTool !== 'rope') return;
  
  // 转换到图片坐标系
  const imagePoint = toImagePoint(clickPoint, imgRect);
  
  // 🔑 检查是否点击了某个物体
  let clickedBody = null;
  for (const assignment of assignments) {
    const canvasContour = toCanvasPoints(assignment.contour, imgRect);
    if (isPointInContour(clickPoint, canvasContour)) {
      clickedBody = assignment;
      break;
    }
  }
  
  if (!ropeCreationState) {
    // 🔑 第一次点击：选择起点
    const firstPoint = {
      x: imagePoint.x,
      y: imagePoint.y,
      bodyName: clickedBody ? clickedBody.label : null  // null 表示固定在空中
    };
    
    setRopeCreationState({
      firstPoint: firstPoint,
      mousePosition: imagePoint
    });
    
    setError('✅ 起点已选择，移动鼠标布局绳子路径，点击第二个点确定终点');
    
  } else {
    // 🔑 第二次点击：确定终点
    const secondPoint = {
      x: imagePoint.x,
      y: imagePoint.y,
      bodyName: clickedBody ? clickedBody.label : null
    };
    
    // 🔑 创建绳子约束数据
    const newRopeConstraint = {
      constraintType: 'rope',
      startPoint: ropeCreationState.firstPoint,
      endPoint: secondPoint
    };
    
    setConstraintRelations(prev => [...prev, newRopeConstraint]);
    setRopeCreationState(null);
    setError('✅ 绳子已创建，可继续创建或点击"创建模拟"');
  }
};

/**
 * 处理鼠标移动（绳子预览）
 */
const handleCanvasMouseMove = (mousePoint, imgRect) => {
  if (ropeCreationState) {
    const imagePoint = toImagePoint(mousePoint, imgRect);
    setRopeCreationState(prev => ({
      ...prev,
      mousePosition: imagePoint
    }));
  }
};

/**
 * 绘制绳子预览
 */
const drawRopePreview = (ctx, imgRect) => {
  if (!ropeCreationState) return;
  
  const start = toCanvasPoint(ropeCreationState.firstPoint, imgRect);
  const end = toCanvasPoint(ropeCreationState.mousePosition, imgRect);
  
  // 🔑 绘制虚线预览
  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  ctx.lineTo(end.x, end.y);
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 4;
  ctx.setLineDash([10, 5]);  // 虚线
  ctx.stroke();
  ctx.setLineDash([]);  // 恢复实线
  
  // 🔑 绘制起点（红色圆点）
  ctx.beginPath();
  ctx.arc(start.x, start.y, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#ff0000';
  ctx.fill();
  
  // 🔑 绘制终点（绿色圆点，跟随鼠标）
  ctx.beginPath();
  ctx.arc(end.x, end.y, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#00ff00';
  ctx.fill();
};
```

---

## 在 physicsEngine.js 中集成绳子

```javascript
import { VerletRope } from './VerletRope';

export function runSimulation({ ... }) {
  
  // ... 前面创建物体的代码 ...
  
  // 🆕 创建绳子系统
  const ropeSystems = [];
  
  constraints.forEach(c => {
    if (c.constraintType === 'rope') {
      // 转换到画布坐标
      const startCanvas = {
        x: c.startPoint.x * sx,
        y: c.startPoint.y * sy
      };
      const endCanvas = {
        x: c.endPoint.x * sx,
        y: c.endPoint.y * sy
      };
      
      // 🔑 创建 Verlet 绳子
      const rope = new VerletRope(startCanvas, endCanvas, 40);
      
      // 🔑 如果起点是刚体，附着上去
      if (c.startPoint.bodyName && bodiesMap[c.startPoint.bodyName]) {
        const body = bodiesMap[c.startPoint.bodyName];
        rope.attachToBody({ 
          body: body, 
          offset: { x: 0, y: 0 } 
        }, true);
      } else {
        // 起点固定在空中
        rope.points[0].pinned = true;
      }
      
      // 🔑 如果终点是刚体，附着上去
      if (c.endPoint.bodyName && bodiesMap[c.endPoint.bodyName]) {
        const body = bodiesMap[c.endPoint.bodyName];
        rope.attachToBody({ 
          body: body, 
          offset: { x: 0, y: 0 } 
        }, false);
      } else {
        // 终点固定在空中
        const lastIdx = rope.points.length - 1;
        rope.points[lastIdx].pinned = true;
      }
      
      ropeSystems.push(rope);
    }
  });
  
  // 🔑 在渲染循环中更新和绘制绳子
  Events.on(render, 'afterRender', () => {
    const ctx = render.canvas.getContext('2d');
    
    ropeSystems.forEach(rope => {
      rope.update();   // 更新物理
      rope.render(ctx); // 绘制
    });
  });
  
  // ... 后面代码 ...
}
```

---

## 完成后的前端效果（详细）

### 阶段一：选择绳子工具

1. **工具栏变化**：
   - "绳子"按钮高亮或选中状态
   - 提示文字："点击物体或画布作为绳子起点"

---

### 阶段二：点击第一个点（起点）

2. **点击刚体**：
   - 刚体中心出现**红色圆点**（直径约 12px）
   - 提示："✅ 起点已选择，移动鼠标布局绳子路径"

3. **点击空白处**：
   - 点击位置出现**红色圆点**
   - 表示绳子固定在空中（临时锚点）

---

### 阶段三：鼠标移动（实时预览）

4. **你能看到**：
   - 从红色圆点拉出一条**黑色虚线**
   - 虚线跟随鼠标实时伸长、改变方向
   - 虚线末端有**绿色圆点**（跟随鼠标）
   - 虚线样式：黑色，4px 粗，虚线间隔 [10, 5]

5. **可以做的**：
   - 移动鼠标到不同位置
   - 观察绳子的预期路径
   - 绕过其他物体（如滑轮）
   - 布局绳子的初始形态

---

### 阶段四：点击第二个点（终点）

6. **虚线变实线**：
   - 黑色虚线变为**黑色实线**
   - 红色和绿色圆点消失
   - 提示："✅ 绳子已创建"

7. **可以继续**：
   - 再次点击创建第二根绳子
   - 或点击"创建模拟"

---

### 阶段五：点击"创建模拟"后

8. **绳子的初始状态**：
   - 绳子从**直线状态**开始
   - 颜色：**黑色** (#000000)
   - 粗细：**4px**

9. **绳子受重力下垂**：
   - 创建后约 0.5 秒，绳子开始下垂
   - 形成自然的**弧形**
   - 中段最低，两端高
   - 下垂程度取决于绳子长度

---

### 阶段六：拖拽连接绳子的物体

10. **拖拽起点物体**：
    - 拖动物体 A 向上
    - 绳子被拉直
    - 如果绳子另一端连接物体 B → B 被拉动
    - 绳子**实时跟随**物体位置

11. **拖拽终点物体**：
    - 拖动物体 B 向左
    - 绳子摆动
    - 物体 A 受到绳子拉力（如果不是固定点）

---

### 阶段七：松手后的效果

12. **绳子摆动**：
    - 松手后绳子继续摆动
    - 摆动幅度逐渐减小（阻尼效果）
    - 约 3-5 秒后恢复静止

13. **绳子下垂**：
    - 静止时，绳子自然下垂
    - 呈现平滑的弧线
    - 符合物理直觉

---

### 阶段八：观察绳子的细节

14. **绳子的柔性**：
    - 绳子不是一条直线
    - 可以看到明显的**曲线**
    - 中段会向下垂
    - 拖拽时会**弯曲、摆动**

15. **绳子的约束性**：
    - 绳子**长度基本不变**（可能有 1-2% 的微小拉伸）
    - 拖拽时绳子会绷紧
    - 但不会无限拉长

16. **绳子的物理特性**：
    - **重力**：绳子节点受重力，自然下垂
    - **阻尼**：摆动会逐渐停止
    - **张力**：绳子被拉紧时会拉动连接的物体
    - **单向约束**：绳子只能拉，不能推

---

## 测试场景

### 测试 1：两个小球用绳子连接

**场景准备**：
- 上传有两个小球的图片（相距约 200px）
- 选择小球 A 和小球 B

**操作步骤**：
1. 选择"绳子"工具
2. 点击小球 A（红色圆点出现）
3. 移动鼠标到小球 B（观察黑色虚线）
4. 点击小球 B（虚线变实线）
5. 点击"创建模拟"

**预期效果**：
- ✅ 绳子连接 A 和 B
- ✅ 绳子自然下垂（弧形）
- ✅ 拖动 A 时，B 被拉动
- ✅ 松手后绳子摆动，逐渐静止

---

### 测试 2：单摆（绳子固定在空中）

**操作步骤**：
1. 选择"绳子"工具
2. 点击画布上方空白处（天花板位置）
3. 移动鼠标到小球 A
4. 点击小球 A
5. 点击"创建模拟"

**预期效果**：
- ✅ 绳子一端固定在空中（临时锚点）
- ✅ 另一端连接小球 A
- ✅ 小球 A 被吊起来
- ✅ 拖动小球 A 到一侧，松手后摆动（单摆效果）

---

### 测试 3：绳子布局路径

**操作步骤**：
1. 选择"绳子"工具
2. 点击小球 A
3. 移动鼠标绕一个大圈（如从左边绕到右边）
4. 观察虚线路径
5. 点击小球 B
6. 点击"创建模拟"

**预期效果**：
- ✅ 绳子按照用户鼠标路径创建
- ✅ 初始形态是绕圈的
- ✅ 创建后在重力作用下调整形态
- ✅ 但大致保持用户布局的方向

---

### 测试 4：绳子拉力传递

**操作步骤**：
1. 创建绳子连接 A 和 B
2. 创建模拟后，等待静止
3. 拖动小球 A 向上快速移动
4. 观察小球 B 的反应

**预期效果**：
- ✅ 绳子被拉直
- ✅ 小球 B 被拉动向上
- ✅ 拉力传递明显
- ✅ 松手后两个球一起摆动

---

## 常见问题

### Q1：绳子抖动严重或不稳定？

**原因**：
- `stiffness` 过低
- 或 `iterations` 太少

**解决**：
```javascript
this.stiffness = 0.95;  // 推荐 0.9-0.98
// 在 solveConstraints 中
for (let iter = 0; iter < 5; iter++) {  // 推荐 5-10 次
```

---

### Q2：绳子无限拉长？

**原因**：约束求解没有正确限制长度

**检查**：
```javascript
// 确保这段代码存在
const diff = (this.segmentLength - dist) / dist * this.stiffness;
```

---

### Q3：绳子对刚体没有拉力？

**原因**：`applyTensionToBody` 没有调用或力太小

**解决**：
```javascript
const tensionForce = stretch * 0.0003;  // 调整系数
```

---

### Q4：绳子穿透物体？

**原因**：当前版本没有碰撞检测（滑轮约束在第三步实现）

**临时方案**：避免绳子与其他物体重叠

---

## 下一步

完成第二步后，进入：
**交互模式实现-第三步-滑轮系统.md**

---

**文档版本**：v1.0  
**预计开发时间**：2-3 天

