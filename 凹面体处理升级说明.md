# 凹面体处理算法升级说明

## 修改概述

将静态凹面体的处理方式从**三角形扇形分解法**升级为 **Douglas-Peucker简化 + poly-decomp凸分解**。

---

## 技术方案

### 原方案（已移除）
- **三角形扇形分解法**：从质心向每条边创建三角形
- **问题**：效果不佳，三角形数量多

### 新方案
**两步走策略：**

#### 步骤1：Douglas-Peucker (DP) 算法简化轮廓
- **作用**：将 SAM 提取的密集轮廓点（可能上千个）简化为 30-50 个关键点
- **原理**：递归分治，保留距离直线较远的关键点，删除冗余点
- **参数**：`DP_EPSILON = 2.5`（可调整）

#### 步骤2：poly-decomp 凸分解
- **作用**：将凹多边形分解为多个凸多边形
- **原理**：识别内角 > 180° 的凹点，在凹点处切割多边形
- **优势**：凸多边形比三角形更大，数量更少，性能更好

---

## 代码修改详情

### 1. 新增依赖引入
```javascript
import decomp from 'poly-decomp';

// 全局注册到 Matter.js
Matter.Common.setDecomp(decomp);
```

### 2. 新增函数

#### `douglasPeucker(points, epsilon)`
- Douglas-Peucker 路径简化算法
- 参数 `epsilon` 控制简化程度（单位：像素）

#### `decomposeToConvexPolygons(points)`
- 使用 poly-decomp 库进行凸分解
- 返回凸多边形数组

#### `polygonCentroid(polygon)`
- 计算多边形质心（替代原 `triangleCentroid`）

### 3. 移除函数
- ✗ `decomposeToTriangleFan()` - 三角形扇形分解
- ✗ `triangleCentroid()` - 三角形质心计算

### 4. 修改静态凹面体处理逻辑
**位置**：`physicsEngine.js` 第 745-790 行左右

**新逻辑**：
1. 使用 DP 算法简化轮廓
2. 使用 poly-decomp 进行凸分解
3. 为每个凸多边形创建静态刚体
4. 组合到 Composite 中

**关键代码**：
```javascript
// 步骤1：DP 简化
const simplified = douglasPeucker(processed, DP_EPSILON);

// 步骤2：凸分解
const convexPolygons = decomposeToConvexPolygons(simplified);

// 步骤3：创建刚体
convexPolygons.forEach((polygon) => {
  const polyCenter = polygonCentroid(polygon);
  const polyBody = Bodies.fromVertices(polyCenter.x, polyCenter.y, ...);
  // 不使用贴图，使用统一填充色
});
```

---

## 参数调整指南

### DP_EPSILON 参数
**文件位置**：`frontend/src/utils/physicsEngine.js` 第 178 行

```javascript
const DP_EPSILON = 2.5;  // ⚠️ 在这里调整
```

**调整建议**：
| 值范围 | 效果 | 适用场景 |
|--------|------|----------|
| 1.0-2.0 | 保留更多细节 | 细小凹陷的物体 |
| 2.5-3.5 | 平衡性能和精度 | **推荐默认值** |
| 4.0+ | 激进简化 | 简单形状，追求性能 |

**影响**：
- 值越小：简化后点越多，精度越高，性能略低
- 值越大：简化后点越少，性能越好，可能丢失细节

---

## 适用范围

### ✅ 会应用新算法的物体
- 后端标识为 `is_concave: true` 的物体
- 且 `role: 'static'` 的静态物体

### ✗ 不受影响的物体
- 凸面体（`is_concave: false`）- 保持原逻辑
- 动态凹面体（`is_concave: true` + `role: 'dynamic'`）- 继续使用凸包近似
- 约束类型元素（`role: 'constraint'`）

**重要**：同一场景中可以同时存在凹面体和凸面体，算法会自动识别并分别处理。

---

## 测试步骤

### 1. 启动项目
```bash
cd frontend
npm run dev
```

### 2. 上传包含凹面体的图片
推荐测试图片类型：
- L 形物体
- U 形槽
- 弧形斜面
- 带缺口的物体
- 半圆弧轨道

### 3. 观察控制台日志
新算法会输出：
```
[物理引擎] DP简化: 1000 点 → 35 点
[物理引擎] 静态凹面体创建成功: 斜面, 分解为 3 个凸多边形
```

### 4. 检查效果
- **视觉效果**：凹面体分解后的凸多边形边界是否合理
- **碰撞效果**：动态物体在凹面体上的碰撞是否准确
- **性能**：凸多边形数量是否比之前的三角形少

### 5. 调试模式（可选）
如需查看分解边界，在代码中取消注释：
```javascript
// frontend/src/utils/physicsEngine.js 第 782 行左右
render: {
  fillStyle: '#94a3b8',
  strokeStyle: '#64748b',  // 取消注释此行
  lineWidth: 1,            // 取消注释此行
}
```

---

## 回退方案

如果新算法出现问题，会自动回退到凸包近似：

1. **DP 简化后顶点不足**：回退到凸包
2. **poly-decomp 分解失败**：回退到凸包

控制台会显示：
```
[物理引擎] DP简化后顶点不足，回退到凸包: 物体名称
[物理引擎] 凸分解失败，回退到凸包: 物体名称
```

---

## 预期改进

### 性能提升
- 凸多边形数量：通常 3-8 个（相比三角形 20-50 个）
- 物理计算量：减少 60-80%

### 精度提升
- 凹陷部分碰撞更准确
- 减少图像噪声导致的微小波动

### 稳定性
- DP 简化减少了极端情况
- poly-decomp 是成熟的凸分解算法

---

## 注意事项

1. **只针对静态凹面体**：动态凹面体仍使用凸包（Matter.js 限制）
2. **不使用贴图**：分解后的凸多边形使用统一填充色（避免贴图重叠）
3. **依赖后端标识**：依赖后端 AI 正确标识 `is_concave` 字段
4. **自相交处理**：poly-decomp 要求多边形无自相交，DP 简化有助于避免此问题

---

## 技术参考

- [Douglas-Peucker 算法](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)
- [poly-decomp 库](https://github.com/schteppe/poly-decomp.js)
- [Matter.js 文档](https://brm.io/matter-js/docs/)
